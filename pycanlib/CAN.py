"""
File: CAN.py

This file contains the implementation of the objects representing a CAN bus to
a system using pycanlib (CAN messages, CAN buses, etc.)
"""

import atexit
import ctypes
import logging
import os
import Queue
import sys
import types
from xml.dom import minidom

from pycanlib import canlib, canstat


canlib.canInitializeLibrary()


CAN_MODULE_LOGGER = logging.getLogger("pycanlib.CAN")
HANDLE_CLASS_LOGGER = logging.getLogger("pycanlib.CAN._Handle")
BUS_CLASS_LOGGER = logging.getLogger("pycanlib.CAN.Bus")
LOG_MESSAGE_CLASS_LOGGER = logging.getLogger("pycanlib.CAN.LogMessage")
CAN_MESSAGE_CLASS_LOGGER = logging.getLogger("pycanlib.CAN.Message")
INFO_MESSAGE_CLASS_LOGGER = logging.getLogger("pycanlib.CAN.InfoMessage")
XML_OBJECT_CLASS_LOGGER = logging.getLogger("pycanlib.CAN.XMLObject")

MAX_DEVICE_DESCR_LENGTH = 256
MAX_MANUFACTURER_NAME_LENGTH = 256
MAX_FW_VERSION_LENGTH = 8
FW_VERSION_ARRAY = ctypes.c_ubyte * MAX_FW_VERSION_LENGTH
MAX_HW_VERSION_LENGTH = 8
HW_VERSION_ARRAY = ctypes.c_ubyte * MAX_HW_VERSION_LENGTH
MAX_CARD_SN_LENGTH = 8
CARD_SN_ARRAY = ctypes.c_ubyte * MAX_CARD_SN_LENGTH
MAX_TRANS_SN_LENGTH = 8
TRANS_SN_ARRAY = ctypes.c_ubyte * MAX_TRANS_SN_LENGTH

try:
    VERSION_NUMBER_FILE = open(os.path.join(os.path.dirname(__file__),
                              "version.txt"), "r")
    __version__ = VERSION_NUMBER_FILE.readline()
    VERSION_NUMBER_FILE.close()
except IOError as read_error:
    print read_error
    __version__ = "UNKNOWN"


class PycanlibError(Exception):
    """
    Class: PycanlibError

    This class is a superclass for all errors that may be generated by
    pycanlib. It allows an application using pycanlib to trap all errors that
    may be caused by a call to pycanlib with a single `except` statement.

    Parent class: Exception
    """
    pass


TIMER_TICKS_PER_SECOND = 1000000
MICROSECONDS_PER_TIMER_TICK = (TIMER_TICKS_PER_SECOND / 1000000)


class InvalidParameterError(PycanlibError):
    """
    Class: InvalidParameterError

    Parent class: PycanlibError
    """

    def __init__(self, parameter_name, parameter_value, reason):
        """
        Constructor: InvalidParameterError

        Parameters:

            parameter_name: name of the invalid parameter
            parameter_value: value of the invalid parameter
            reason: a string detailing the reason why the parameter is invalid
        """
        PycanlibError.__init__(self)
        self.parameter_name = parameter_name
        self.parameter_value = parameter_value
        self.reason = reason

    def __str__(self):
        return ("%s: invalid value '%s' for parameter '%s' - %s" %
          (self.__class__.__name__, self.parameter_value,
          self.parameter_name, self.reason))


class InvalidMessageParameterError(InvalidParameterError):
    """
    Class: InvalidMessageParameterError

    Subclass of InvalidParameterError thrown when an invalid parameter is
    passed to the constructor of a Message object (either CAN.LogMessage,
    CAN.InfoMessage, or CAN.Message)

    Parent class: InvalidParameterError
    """
    pass


class InvalidBusParameterError(InvalidParameterError):
    """
    Class: InvalidBusParameterError

    Subclass of InvalidParameterError thrown when an invalid parameter is
    passed to the constructor of a CAN.Bus object.

    Parent class: InvalidParameterError
    """
    pass


class XMLObject(object):
    """
    Class: XMLObject

    Superclass for all pycanlib entities that have an XML representation.
    This class provides a method which converts an arbitrary object into
    XML format.
    
    Parent class: object
    """

    def __init__(self, xml=None):
        """
        Constructor: XMLObject
        
        Parameters:
            xml: XML fragment used to construct this object. Consists of a
            single top-level block containing many lower level blocks, each
            containing one of the object's instance variables. These instance
            variables must be string representations of basic Python types
            (int, string, float, etc.).
        """
        if xml is not None:
            if xml.nodeName != self.__class__.__name__:
                raise InvalidMessageParameterError("xml", xml,
                  ("XML fragment does not represent an object of type %s" %
                  self.__class__.__name__))
            for (_attr_name, _attr_val) in xml.attributes.items():
                try:
                    self.__dict__[_attr_name] = eval(_attr_val)
                except (NameError, SyntaxError):
                    self.__dict__[_attr_name] = _attr_val
            if len(xml.childNodes) > 0:
                if self.__class__.__name__ is "MessageList":
                    self.messages = []
                    for _node in xml.childNodes:
                        self.messages.append(Message(_node))

    def to_xml(self):
        """
        Method: to_xml

        Produces an XML representation of this instance of XMLObject (or any
        of its subclasses). See below for an example of the XML produced by
        this function.
        
        Parameters:

            Nothing

        Returns:

            XML element representing this instance of LogMessage (or one of
            its subclasses)

        Example:

        >>> from pycanlib import CAN; \
            msg = CAN.LogMessage(timestamp=5.0); \
            print msg.to_xml().toprettyxml(indent="    ")
        <LogMessage>
            <timestamp>
                5.0
            </timestamp>
        </LogMessage>
        <BLANKLINE>
        """
        _document = minidom.Document()
        retval = _document.createElement(self.__class__.__name__)
        XML_OBJECT_CLASS_LOGGER.debug("in XMLObject.to_xml() - %s" %
          self.__dict__)
        for (_var_name, _var_value) in self.__dict__.items():
            if (self.__class__.__name__ is "MessageList") and (_var_name
              is "messages"):
                for _message in _var_value:
                    retval.appendChild(_message.to_xml())
            else:
                retval.setAttribute(_var_name, "%s" % _var_value)
        return retval


class LogMessage(XMLObject):
    """
    Class: LogMessage

    Superclass for all loggable messages produced by either pycanlib or any
    higher level protocol libraries built on top of it.

    Parent class: XMLObject
    """

    def __init__(self, xml=None, timestamp=0.0):
        """
        Constructor: LogMessage

        Parameters:

            xml (optional, default=None) - XML fragment used to reconstruct
              an instance of LogMessage.
            timestamp (optional, default=0.0) - message timestamp (in
              seconds). Must be a non-negative float or int, otherwise an
              InvalidMessageParameterError is thrown.
        """
        _start_msg = ("Starting LogMessage.__init__ - timestamp %s" %
          timestamp)
        LOG_MESSAGE_CLASS_LOGGER.debug(_start_msg)
        XMLObject.__init__(self, xml)
        LOG_MESSAGE_CLASS_LOGGER.debug("in LogMessage.__init__ - %s" % self.__dict__)
        if xml is None:
            if not isinstance(timestamp, (types.FloatType, types.IntType)):
                _bad_timestamp_error = InvalidMessageParameterError("timestamp",
                  timestamp, ("expected float or int; received '%s'" %
                  timestamp.__class__.__name__))
                LOG_MESSAGE_CLASS_LOGGER.debug("LogMessage.__init__: %s" %
                  _bad_timestamp_error)
                raise _bad_timestamp_error
            if timestamp < 0:
                _bad_timestamp_error = InvalidMessageParameterError("timestamp",
                  timestamp, "timestamp value must be positive")
                LOG_MESSAGE_CLASS_LOGGER.debug("LogMessage.__init__: %s" %
                  _bad_timestamp_error)
                raise _bad_timestamp_error
            self.timestamp = timestamp
        _finish_msg = "LogMessage.__init__ completed successfully"
        LOG_MESSAGE_CLASS_LOGGER.debug(_finish_msg)

    def __str__(self):
        return "%.6f" % self.timestamp


class Message(LogMessage):
    """
    Class: Message

    Subclass of LogMessage representing a CAN message.

    Parent class: LogMessage
    """

    def __init__(self, xml=None, device_id=0, payload=None, dlc=0, flags=0,
      timestamp=0.0):
        """
        Constructor: Message

        Parameters:

            device_id (optional, default=0) - The value of this message's
              identifier field. Must be an integer in the range [0, 2**11 -1],
              otherwise an InvalidMessageParameterError is thrown.
            payload (optional, default=None) - The message payload,
              represented as a Python array of integers, each integer being in
              the range [0, 2**8-1]. If the message payload is zero bytes in
              length, this value is None. If this array contains more than 8
              objects, or if any object in it is not an integer or has a value
              outside the allowable range, an InvalidMessageParameterError is
              thrown.
            dlc (optional, default=0) - The DLC value of this message. Must be
              an integer in the range [0, 8], otherwise an
              InvalidMessageParameterError is thrown.
            flags (optional, default=0) - The flags word for this message. Must
              be an integer in the range [0, 2**16-1], otherwise
              InvalidMessageParameterError is thrown.
            timestamp (optional, default=0.0) - see LogMessage
        """
        if payload is None:
            payload = []
        LogMessage.__init__(self, xml, timestamp)
        if xml is None:
            CAN_MESSAGE_CLASS_LOGGER.debug("in Message.__init__ - %s" % self.__dict__)
            if not isinstance(device_id, types.IntType):
                raise InvalidMessageParameterError("device_id", device_id,
                  ("expected int; received '%s'" %
                  device_id.__class__.__name__))
            if device_id not in range(0, 2 ** 11):
                raise InvalidMessageParameterError("device_id", device_id,
                  "device_id must be in range [0, 2**11-1]")
            self.device_id = device_id
            if len(payload) not in range(0, 9):
                raise InvalidMessageParameterError("payload", payload,
                  "payload array length must be in range [0, 8]")
            for item in payload:
                if not isinstance(item, types.IntType):
                    raise InvalidMessageParameterError("payload", payload,
                      ("payload array must contain only integers; found '%s'" %
                      item.__class__.__name__))
                if item not in range(0, 2 ** 8):
                    raise InvalidMessageParameterError("payload", payload,
                      "payload array element values must be in range [0, 2**8-1]")
            self.payload = payload
            if not isinstance(dlc, types.IntType):
                raise InvalidMessageParameterError("dlc", dlc,
                  "expected int; received %s" % dlc.__class__.__name__)
            if dlc not in range(0, 9):
                raise InvalidMessageParameterError("dlc", dlc,
                  "DLC value must be in range [0, 8]")
            self.dlc = dlc
            if not isinstance(flags, types.IntType):
                raise InvalidMessageParameterError("flags", flags,
                  "expected int; received %s" % flags.__class__.__name__)
            if flags not in range(0, 2 ** 16):
                raise InvalidMessageParameterError("flags", flags,
                  "flags value must be in range [0, 2**16-1]")
            self.flags = flags

    def __str__(self):
        _field_strings = []
        _field_strings.append(LogMessage.__str__(self))
        _field_strings.append("%.4x" % self.device_id)
        _field_strings.append("%.4x" % self.flags)
        _field_strings.append("%d" % self.dlc)
        _data_strings = []
        if self.payload != None:
            for byte in self.payload:
                _data_strings.append("%.2x" % byte)
        if len(_data_strings) > 0:
            _field_strings.append(" ".join(_data_strings))
        return "\t".join(_field_strings)


class InfoMessage(LogMessage):
    """
    Class: InfoMessage

    Subclass of LogMessage representing an information message - basically
    a timestamped string.

    Parent class: LogMessage
    """

    def __init__(self, xml=None, timestamp=0.0, info=None):
        """
        Constructor: InfoMessage

        Parameters:
            timestamp (optional, default=0.0) - see LogMessage
            info (optional, default=None) - information contained in this
              message. May be any Python object - the object will be converted
              to a string when a string or XML representation of the
              InfoMessage is created.
        """
        LogMessage.__init__(self, xml, timestamp)
        if xml is None:
            self.info = info

    def __str__(self):
        retval = "%s" % LogMessage.__str__(self)
        if self.info != None:
            retval += ("\t%s" % self.info)
        return retval


class MessageList(XMLObject):
    """
    Class: MessageList
    
    Class representing a list of messages. This class is used to define the
    filter criteria applied to a given section of a CAN traffic log.
    
    Parent class: XMLObject
    """

    def __init__(self, xml=None, messages=[], filter_criteria=None,
      message_type="CAN", name="default"):
        """
        Constructor: MessageList
        
        Parameters:
            xml (optional, default=None): XML fragment used to reconstruct
              this MessageList object.
            messages (optional, default=[]): list of CAN.Message objects to be
              included in this MessageList object.
            filter_criteria (optional, default=None): filter criteria applied
              to the messages in this MessageList. **TO-DO:** define this
              better, probably in terms of message types and device IDs
              included and excluded
            message_type (optional, default="CAN"): type of messages contained in
              this list. May be either "CAN", for a simple CAN protocol, or the name
              of any CAN-based higher level protocol.
            name (optional, default="default"): name of this message list, used to
              distinguish between message lists in XML and TDV log files
        """
        XMLObject.__init__(self, xml)
        if xml is None:
            self.messages = messages
            self.filter_criteria = filter_criteria
            self.message_type = message_type
            self.name = name
            self.start_timestamp = self.messages[0].timestamp
            self.end_timestamp = self.messages[len(self.messages)-1].timestamp

    def __str__(self):
        _header_str = "Message List '%s'"
        _header_str = _header_str % self.name
        retval = "-"*len(_header_str)
        retval += "\n%s\n" % _header_str
        retval += "-"*len(_header_str)
        retval += "\n"
        retval += "Applied filters: %s\n" % self.filter_criteria
        retval += "Message type: %s\n" % self.message_type
        retval += "Start timestamp = %f\n" % self.start_timestamp
        retval += "End timestamp = %f\n" % self.end_timestamp
        for _msg in self.messages:
            retval += "%s\n" % _msg
        return retval

READ_HANDLE_REGISTRY = {}
WRITE_HANDLE_REGISTRY = {}


def _receive_callback(handle):
    """
    Method: _receive_callback

    This function is called by CANLIB when a message is received on any CAN
    bus handle opened by pycanlib. It dispatches the event to the CAN._Handle
    instance associated with the CANLIB handle that generated the event.

    Parameters:

        handle - number of the CANLIB handle that generated the event.
    """
    #called by the callback registered with CANLIB, but coverage can't figure
    #that out
    CAN_MODULE_LOGGER.debug("Entering _receive_callback for handle %d" % handle)
    if READ_HANDLE_REGISTRY[handle] != None:
        READ_HANDLE_REGISTRY[handle].receive_callback()
    CAN_MODULE_LOGGER.debug("Leaving _receive_callback for handle %d" % handle)
    return 0


RX_CALLBACK = canlib.CALLBACKFUNC(_receive_callback)


def _transmit_callback(handle):
    """
    Method: _transmit_callback

    This function is called by CANLIB when a transmission on any CAN bus
    handle opened by pycanlib completes. It dispatches the event to the
    CAN._Handle instance associated with the CANLIB handle that generated the
    event.

    Parameters:

        handle - number of the CANLIB handle that generated the event.
    """
    CAN_MODULE_LOGGER.debug("Entering _transmit_callback for handle %d" %
                            handle)
    if WRITE_HANDLE_REGISTRY[handle] != None:
        WRITE_HANDLE_REGISTRY[handle].transmit_callback()
    CAN_MODULE_LOGGER.debug("Leaving _transmit_callback for handle %d" % handle)
    return 0


TX_CALLBACK = canlib.CALLBACKFUNC(_transmit_callback)


class _Handle(object):
    """
    Class: _Handle

    Class that represents a CANLIB CAN bus handle (the result of opening a
    CAN channel).

    Parent class: object
    """

    def __init__(self, channel, flags):
        """
        Constructor: _Handle

        Parameters:
            channel - number of the CANLIB channel number this handle will
              refer to.
            flags - flags passed to CANLIB when the handle is opened. See the
              CANLIB SDK documentation for canOpenChannel for more
              information.

        **TO-DO**: "flags" breaks the abstraction provided by _Handle - change
        it to a set of booleans representing properties that better fit the
        level of abstraction provided by _Handle
        """
        _num_channels = ctypes.c_int(0)
        canlib.canGetNumberOfChannels(ctypes.byref(_num_channels))
        if channel not in range(0, _num_channels.value):
            raise InvalidBusParameterError("channel", channel,
              ("available channels on this system are in the range [0, %d]" %
              _num_channels.value))
        self.channel = channel
        if flags & (0xFFFF - canlib.FLAGS_MASK) != 0:
            raise InvalidBusParameterError("flags", flags,
              "must contain only the canOPEN_* flags listed in canlib.py")
        self.flags = flags
        try:
            self._canlib_handle = canlib.canOpenChannel(channel, flags)
        except canlib.CANLIBError as open_channel_error:
            if open_channel_error.error_code == canstat.canERR_NOTFOUND:
                raise InvalidBusParameterError("flags", flags,
                  "no hardware is available that has all these capabilities")
            else:
                raise open_channel_error
        self.listeners = []
        self.tx_queue = Queue.Queue(0)
        _timer_res = ctypes.c_long(MICROSECONDS_PER_TIMER_TICK)
        canlib.canFlushReceiveQueue(self._canlib_handle)
        canlib.canFlushTransmitQueue(self._canlib_handle)
        canlib.canIoCtl(self._canlib_handle, canlib.canIOCTL_SET_TIMER_SCALE,
          ctypes.byref(_timer_res), 4)
        canlib.canBusOn(self._canlib_handle)
        self.reading = False
        self.writing = False
        self.receive_callback_enabled = True
        self.transmit_callback_enabled = True

    def get_canlib_handle(self):
        """
        Method: get_canlib_handle

        Returns the integer index into CANLIB's table of CAN handles for this
        _Handle object.

        **TO-DO**: remove this - it breaks the abstraction of Handle
        """
        return self._canlib_handle

    def transmit_callback(self):
        """
        Method: transmit_callback

        Method called by _transmit_callback to service a "transmission
        complete" event for this _Handle object.
        """
        HANDLE_CLASS_LOGGER.debug("Transmit buffer level for handle %d: %d" %
          (self._canlib_handle, self.get_transmit_buffer_level()))
        if not self.writing and self.transmit_callback_enabled:
            self.writing = True
            try:
                _to_send = self.tx_queue.get_nowait()
            except Queue.Empty:
                #this part of transmit_callback executes when CANLIB fires the
                #transmit callback event for this handle, but coverage isn't
                #smart enough to figure this out, so it thinks it isn't called
                #at all
                self.writing = False
                return
            _byte_strings = [("%c" % byte) for byte in _to_send.payload]
            _payload_string = "".join(_byte_strings)
            canlib.canWrite(self._canlib_handle, _to_send.device_id,
              _payload_string, _to_send.dlc, _to_send.flags)
            self.writing = False

    def write(self, msg):
        """
        Method: write

        Method called to write a message to the CANLIB handle represented by
        this _Handle object.

        Parameters:

            msg - message to write. This must be an instance of CAN.Message

        Returns:

            Nothing
        """
        _old_size = self.tx_queue.qsize()
        if isinstance(msg, Message):
            self.tx_queue.put_nowait(msg)
            if _old_size == 0:
                self.transmit_callback()

    def receive_callback(self):
        """
        Method: receive_callback

        Method called by _receive_callback to service a "new message received"
        event for this _Handle object.
        """
        #this is called by the callback registered with CANLIB, but because
        #coverage isn't smart enough to figure this out, it thinks this
        #function is never called at all
        _callback_entry_msg = "Entering _Handle.ReceiveCallback"
        HANDLE_CLASS_LOGGER.info(_callback_entry_msg)
        if not self.reading and self.receive_callback_enabled:
            self.reading = True
            _device_id = ctypes.c_long(0)
            _data = ctypes.create_string_buffer(8)
            _dlc = ctypes.c_uint(0)
            _flags = ctypes.c_uint(0)
            _timestamp = ctypes.c_long(0)
            _status = canlib.canRead(self._canlib_handle,
              ctypes.byref(_device_id), ctypes.byref(_data),
              ctypes.byref(_dlc), ctypes.byref(_flags),
              ctypes.byref(_timestamp))
            while _status.value == canstat.canOK:
                _data_array = []
                for _char in _data:
                    _data_array.append(ord(_char))
                HANDLE_CLASS_LOGGER.debug("Creating new Message object")
                _rx_msg = Message(device_id=_device_id.value,
                                  payload=_data_array[:_dlc.value],
                                  dlc=int(_dlc.value),
                                  flags=int(_flags.value),
                                  timestamp = (float(_timestamp.value) /
                                    TIMER_TICKS_PER_SECOND))
                for _listener in self.listeners:
                    _listener.on_message_received(_rx_msg)
                _status = canlib.canRead(self._canlib_handle,
                  ctypes.byref(_device_id), ctypes.byref(_data),
                  ctypes.byref(_dlc), ctypes.byref(_flags),
                  ctypes.byref(_timestamp))
            _exit_str = "Leaving _Handle.ReceiveCallback - status is %s (%d)"
            _callback_exit_msg = (_exit_str %
              (canstat.canStatusLookupTable[_status.value], _status.value))
            HANDLE_CLASS_LOGGER.info(_callback_exit_msg)
            canlib.kvSetNotifyCallback(self._canlib_handle, RX_CALLBACK,
              ctypes.c_void_p(None), canstat.canNOTIFY_RX)
            self.reading = False

    def add_listener(self, listener):
        """
        Method: add_listener

        This method adds a listener to this _Handle object - that is, an
        object that needs to be notified when a new message is received by
        this _Handle.

        Parameters:

            listener - listener to append. May be any Python object, provided
            it has an on_message_received message, taking only a CAN.Message
            object as a parameter.
        """
        self.listeners.append(listener)

    def read_timer(self):
        """
        Method: read_timer

        This method reads the CAN bus timer for this handle.

        Returns:

            Time elapsed since this handle was opened, in CANLIB timer ticks.
        """
        return canlib.canReadTimer(self._canlib_handle)

    def get_receive_buffer_level(self):
        """
        Method: get_receive_buffer_level

        Returns:

            Number of messages in the CANLIB receive buffer for this handle.
        """
        #this is called by the callback registered with CANLIB, but because
        #coverage isn't smart enough to figure this out, it thinks this
        #function is never called at all
        rx_level = ctypes.c_int(0)
        canlib.canIoCtl(self._canlib_handle,
          canlib.canIOCTL_GET_RX_BUFFER_LEVEL, ctypes.byref(rx_level), 4)
        return rx_level.value

    def get_transmit_buffer_level(self):
        """
        Method: get_transmit_buffer_level

        Returns:

            Number of messages in the CANLIB transmit buffer for this handle.
        """
        tx_level = ctypes.c_int(0)
        canlib.canIoCtl(self._canlib_handle,
          canlib.canIOCTL_GET_TX_BUFFER_LEVEL, ctypes.byref(tx_level), 4)
        return tx_level.value

    def get_device_description(self):
        """
        Method: get_device_description

        Returns: a string representation of the name of the CAN device the
          channel has been opened on. See the doctest below for an example of
          usage for this function.

        Example (with a Kvaser Leaf Light HS device as CANLIB channel 0):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_description();
        Kvaser Leaf Light HS
        """
        _buffer = ctypes.create_string_buffer(MAX_DEVICE_DESCR_LENGTH)
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_DEVDESCR_ASCII, ctypes.byref(_buffer),
          ctypes.c_size_t(MAX_DEVICE_DESCR_LENGTH))
        return _buffer.value

    def get_device_manufacturer_name(self):
        """
        Method: get_device_manufacturer_name

        Returns: a string representation of the name of the manufacturer of
        the CAN device the channel has been opened on. See the doctest below
        for an example of usage for this function.

        Example (with a Kvaser device as CANLIB channel 0):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_manufacturer_name();
        Kvaser AB
        """
        _buffer = ctypes.create_string_buffer(MAX_MANUFACTURER_NAME_LENGTH)
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_MFGNAME_ASCII, ctypes.byref(_buffer),
          ctypes.c_size_t(MAX_MANUFACTURER_NAME_LENGTH))
        return _buffer.value

    def get_device_firmware_version(self):
        """
        Method: get_device_firmware_version

        Returns: a string representation of the firmware version running on
        the CAN device the channel has been opened on, in the format w.x.y.z,
        where w is the major revision number, x the minor revision number, y
        the release number, and z the build number. See the doctest below for
        an example of usage for this function.

        Example (with a Kvaser Leaf Light HS running firmware version 2.0.50.0
        as CANLIB channel 0):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_firmware_version();
        2.0.50.0
        """
        _buffer = FW_VERSION_ARRAY()
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_CARD_FIRMWARE_REV, ctypes.byref(_buffer),
          ctypes.c_size_t(MAX_FW_VERSION_LENGTH))
        _version_number = []
        for i in [6, 4, 0, 2]:
            _version_number.append((_buffer[i + 1] << 8) + _buffer[i])
        return "%d.%d.%d.%d" % (_version_number[0], _version_number[1],
          _version_number[2], _version_number[3])

    def get_device_hardware_version(self):
        """
        Method: get_device_hardware_version

        Returns: a string representation of the hardware revision of the CAN
        device the channel has been opened on, in the format x.y, where x is
        the major revision number, and y is the minor revision number. See the
        doctest below for an example of usage for this function.

        Example (with a hardware version 1.0 Kvaser Leaf Light HS as CANLIB
        channel 0):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_hardware_version()
        1.0
        """
        _buffer = HW_VERSION_ARRAY()
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_CARD_HARDWARE_REV, ctypes.byref(_buffer),
          ctypes.c_size_t(MAX_HW_VERSION_LENGTH))
        _version_number = []
        for i in [2, 0]:
            _version_number.append((_buffer[i + 1] << 8) + _buffer[i])
        return "%d.%d" % (_version_number[0], _version_number[1])

    def get_device_card_serial(self):
        """
        Method: get_device_card_serial

        Returns: an integer representing the serial number of the CAN
        *card* (not transceiver) the channel has been opened on. Note that
        this is only the serial number of the card. If your device has a
        separate transceiver, this will have a separate serial number, which
        can be accessed using _Handle.get_device_transceiver_serial(). See the
        doctest below for an example of usage for this function.

        Example (with a Kvaser Leaf Light HS with serial number 15198 as CANLIB
        channel 0):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_card_serial()
        15198
        """
        _buffer = CARD_SN_ARRAY()
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_CARD_SERIAL_NO, ctypes.byref(_buffer),
          ctypes.c_size_t(MAX_CARD_SN_LENGTH))
        _serial_number = 0
        for i in xrange(len(_buffer)):
            _serial_number += (_buffer[i] << (8 * i))
        return _serial_number

    def get_device_transceiver_serial(self):
        """
        Method: get_device_transceiver_serial

        Returns: an integer representing the serial number of the CAN
        transceiver of the device the channel has been opened on. If the
        transceiver of the device the channel has been opened on does not
        have a serial number, this function returns 0. Note that this is *not*
        the serial number of the card. See the doctest below for an example of
        usage for this function.

        Example (with a Kvaser Leaf Light HS - which has no separate
        transceiver - as CANLIB channel 0):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_transceiver_serial()
        0
        """
        _buffer = TRANS_SN_ARRAY()
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_TRANS_SERIAL_NO, ctypes.byref(_buffer),
          ctypes.c_size_t(MAX_TRANS_SN_LENGTH))
        serial_number = 0
        for i in xrange(len(_buffer)):
            serial_number += (_buffer[i] << (8 * i))
        return serial_number

    def get_device_card_number(self):
        """
        Method: get_device_card_number

        Returns: an integer representing the number of the card the channel
        has been opened on (out of all the cards present in the system). See
        the doctest below for an example of usage for this function.

        Example (where CANLIB channel 0 is opened on the system's CANLIB
        card 1):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_card_number()
        1
        """
        _buffer = ctypes.c_ulong(0)
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_CARD_NUMBER, ctypes.byref(_buffer),
          ctypes.c_size_t(4))
        return _buffer.value

    def get_device_channel_on_card(self):
        """
        Method: get_device_channel_on_card

        Returns: For cards which have multiple physical CAN interfaces (like
        the Kvaser USBCAN II), this returns the number of the interface this
        channel has been opened on. For cards with only one physical CAN
        interface (like the Kvaser Leaf Light HS), it will always return 0.
        See the doctest below for an example of usage for this function.

        Example (where CANLIB channel 0 is opened on a Kvaser Leaf Light HS
        device, which has only one physical CAN interface):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_channel_on_card()
        0
        """
        _buffer = ctypes.c_ulong(0)
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_CHAN_NO_ON_CARD, ctypes.byref(_buffer),
          ctypes.c_size_t(4))
        return _buffer.value

    def get_device_transceiver_type(self):
        """
        Method: get_device_transceiver_type
        
        Returns: the type of transceiver attached to the card this channel has
        been opened on. If this transceiver type is not known to CANLIB (a
        list of known transceiver types is provided in canstat.py), this
        function returns a message indicating this.

        Example (where CANLIB channel 0 is opened on a Kvaser Leaf Light HS
        device, which has an 82C251 transceiver):

        >>> from pycanlib import CAN; \
            print CAN._Handle(0, 0).get_device_transceiver_type()
        82C251
        """
        _buffer = ctypes.c_ulong(0)
        canlib.canGetChannelData(self.channel,
          canlib.canCHANNELDATA_TRANS_TYPE, ctypes.byref(_buffer),
          ctypes.c_size_t(4))
        try:
            return canstat.canTransceiverTypeStrings[_buffer.value]
        except KeyError:
            return "Transceiver type %d is unknown to CANLIB" % _buffer.value

    def get_statistics(self):
        """
        Method: get_statistics

        Returns: a BusStatistics instance containing the statistics collected
        for this bus handle from the time it was opened. See the BusStatistics
        class documentation for more information about the specific statistics
        available.

        Example:

        >>> from pycanlib import CAN; \
            _stats = CAN._Handle(0, 0).get_statistics(); \
            print type(_stats)
        <class 'pycanlib.CAN.BusStatistics'>
        """
        canlib.canRequestBusStatistics(self._canlib_handle)
        _stat_struct = canlib.c_canBusStatistics()
        canlib.canGetBusStatistics(self._canlib_handle,
          ctypes.byref(_stat_struct), ctypes.c_uint(28))
        return BusStatistics(_stat_struct.std_data,
                             _stat_struct.std_remote,
                             _stat_struct.ext_data,
                             _stat_struct.ext_remote,
                             _stat_struct.err_frame,
                             _stat_struct.bus_load,
                             _stat_struct.overruns)

class BusStatistics(XMLObject):
    """
    Class: BusStatistics

    Container class for the statistics collected by CANLIB for each handle it
    maintains.

    Parent class: XMLObject
    """
    def __init__(self, xml=None, std_data=0, std_remote=0, ext_data=0,
      ext_remote=0, err_frame=0, bus_load=0, overruns=0):
        """
        Constructor: BusStatistics

        Parameters:
            std_data: the number of standard (CAN 2.0A, 11-bit arbitration
              field) data messages received by this handle
            std_remote: the number of standard (CAN 2.0A, 11-bit arbitration
              field) remote messages received by this handle
            ext_data: the number of extended (CAN 2.0B, 29-bit arbitration
              field) data messages received by this handle
            ext_remote: the number of extended (CAN 2.0B, 29-bit arbitration
              field) remote messages received by this handle
            err_frame: the number of error frames received by this handle
            bus_load: the traffic load on the bus this handle is connected to
              (represented as an integer between 0 and 10000, where 0 = 0.00%
              and 10000 = 100.00%)
        """
        XMLObject.__init__(self)
        self.std_data = std_data
        self.std_remote = std_remote
        self.ext_data = ext_data
        self.ext_remote = ext_remote
        self.err_frame = err_frame
        self.bus_load = float(bus_load)/100
        self.overruns = overruns


def _get_handle(channel_number, flags, registry):
    """
    Method: _get_handle

    This function gets a handle with the given channel number from the given
    handle registry, if a channel with the given flags value is available. If
    one is not available, a new handle is created using the passed channel
    number and flags values, and registered in the given handle registry.

    Parameters:
        channel_number: the CANLIB channel number of the handle to be retrieved.
        flags: the flags value used to open the handle to be retrieved.
        registry: the registry the handle is to be retrieved from (either
          READ_HANDLE_REGISTRY or WRITE_HANDLE_REGISTRY)

    Returns:
        A CAN._Handle object representing a CANLIB handle to the given channel,
        with the given flags value, registered in the given handle registry.
    """
    _found_handle = False
    handle = None
    for _key in registry.keys():
        if (registry[_key].channel == channel_number) and \
          (registry[_key].flags == flags):
            _found_handle = True
            handle = registry[_key]
    if not _found_handle:
        handle = _Handle(channel_number, flags)
        registry[handle.get_canlib_handle()] = handle
    if registry == READ_HANDLE_REGISTRY:
        CAN_MODULE_LOGGER.debug("Setting notify callback for read handle %d" %
          handle.get_canlib_handle())
        canlib.kvSetNotifyCallback(handle.get_canlib_handle(), RX_CALLBACK,
          ctypes.c_void_p(None), canstat.canNOTIFY_RX)
    else:
        CAN_MODULE_LOGGER.debug("Setting notify callback for write handle %d" %
          handle.get_canlib_handle())
        canlib.kvSetNotifyCallback(handle.get_canlib_handle(), TX_CALLBACK,
          ctypes.c_void_p(None), canstat.canNOTIFY_TX)
    return handle


class ChannelInfo(XMLObject):
    """
    Class: ChannelInfo

    This is a container class for information about a specific channel's
    hardware - firmware version, serial number(s), hardware version, etc.

    Parent class: XMLObject
    """

    def __init__(self, xml=None, channel=0, name="", manufacturer="",
      fw_version="", hw_version="", card_serial=0, trans_serial=0,
      trans_type="", card_number=0, channel_on_card=0):
        """
        Constructor: ChannelInfo

        Parameters:
            channel: CANLIB channel number
            name: name of the device the channel is opened on
            manufacturer: manufacturer of the device the channel is opened on
            fw_version: firmware version installed on the device the channel
              is opened on
            hw_version: hardware version of the device the channel is opened
              on
            card_serial: serial number of the *card* the channel is opened on
            trans_serial: serial number of the *transceiver* this channel
               uses to connect to the bus (if this transceiver has a serial
               number)
            trans_type: string name of the type of transceiver this channel
              uses to connect to the bus
            card_number: number of the card the channel is opened on in the
              computer
            channel_on_card: card channel that this CANLIB channel is opened
              on
        """
        XMLObject.__init__(self, xml)
        if xml is None:
            self.channel = channel
            self.name = name
            self.manufacturer = manufacturer
            self.fw_version = fw_version
            self.hw_version = hw_version
            self.card_serial = card_serial
            self.trans_serial = trans_serial
            self.trans_type = trans_type
            self.card_number = card_number
            self.channel_on_card = channel_on_card

    def __str__(self):
        retval = "-"*len("Channel Info")
        retval += "\nChannel Info\n"
        retval += "-"*len("Channel Info")
        retval += "\n"
        retval += "CANLIB channel: %s\n" % self.channel
        retval += "Name: %s\n" % self.name
        retval += "Manufacturer: %s\n" % self.manufacturer
        retval += "Firmware version: %s\n" % self.fw_version
        retval += "Hardware version: %s\n" % self.hw_version
        retval += "Card serial number: %s\n" % self.card_serial
        retval += "Transceiver type: %s\n" % self.trans_type
        retval += "Transceiver serial number: %s\n" % self.trans_serial
        retval += "Card number: %s\n" % self.card_number
        retval += "Channel on card: %s\n" % self.channel_on_card
        retval += "\n"
        return retval


class LogInfo(XMLObject):
    """
    Class: LogInfo

    Container class for information about a message log

    Parent class: XMLObject
    """

    def __init__(self, xml=None, log_start_time=None, log_end_time=None,
      original_file_name="default.xml",
      test_location="default", tester_name="default"):
        XMLObject.__init__(self, xml)
        if xml is None:
            self.log_start_time = log_start_time
            self.log_end_time = log_end_time
            self.original_file_name = original_file_name
            self.test_location = test_location
            self.tester_name = tester_name

    def __str__(self):
        retval = "-"*len("Log Info")
        retval += "\nLog Info\n"
        retval += "-"*len("Log Info")
        retval += "\n"
        retval += "Start time: %s\n" % self.log_start_time
        retval += "End time: %s\n" % self.log_end_time
        retval += "Original XML file name: %s\n" % self.original_file_name
        retval += "Test Location: %s\n" % self.test_location
        retval += "Tester name: %s\n" % self.tester_name
        retval += "\n"
        return retval


class MachineInfo(XMLObject):
    """
    Class: MachineInfo

    Container class for information about the machine pycanlib is running on

    Parent class: XMLObject
    """

    def __init__(self, xml=None, machine_name="", python_version="", os_type=""):
        """
        Constructor: MachineInfo

        Parameters:
            machine_name: name of the machine pycanlib is running on
            python_version: version of the Python installation pycanlib is
              installed on
            os_type: type of OS pycanlib is running on
        """
        XMLObject.__init__(self, xml)
        if xml is None:
            self.machine_name = machine_name
            self.python_version = python_version
            self.os_type = os_type
            self.canlib_version = get_canlib_info()
            self.pycanlib_version = __version__

    def __str__(self):
        retval = "-"*len("Machine Info")
        retval += "\nMachine Info\n"
        retval += "-"*len("Machine Info")
        retval += "\n"
        retval += "Machine name: %s\n" % self.machine_name
        retval += "Python: %s\n" % self.python_version
        retval += "OS: %s\n" % self.os_type
        retval += "CANLIB: %s\n" % self.canlib_version
        retval += "pycanlib: %s\n" % self.pycanlib_version
        retval += "\n"
        return retval


def get_host_machine_info():
    """
    Method: get_host_machine_info

    Returns: a MachineInfo object containing information about the host
    machine running pycanlib.
    """
    if sys.platform == "win32":
        _machine_name = os.getenv("COMPUTERNAME")
    else:
        _machine_name = os.getenv("HOSTNAME")
    _python_version = sys.version[:sys.version.index(" ")]
    return MachineInfo(machine_name=_machine_name,
                       python_version=_python_version,
                       os_type=sys.platform)


def get_canlib_info():
    """
    Method: get_canlib_info

    Returns the version of the CANLIB SDK installed on the host machine, as
    a string.
    """
    _canlib_prod_ver_32 = \
      canlib.canGetVersionEx(canlib.canVERSION_CANLIB32_PRODVER32)
    _major_ver_no = (_canlib_prod_ver_32 & 0x00FF0000) >> 16
    _minor_ver_no = (_canlib_prod_ver_32 & 0x0000FF00) >> 8
    if (_canlib_prod_ver_32 & 0x000000FF) != 0:
        _minor_ver_letter = "%c" % (_canlib_prod_ver_32 & 0x000000FF)
    else:
        _minor_ver_letter = ""
    return "%d.%d%s" % (_major_ver_no, _minor_ver_no, _minor_ver_letter)


def create_log_xml_tree(host_info, log_info, channel_info, msg_lists):
    """
    Method: create_log_xml_tree

    Given a list of messages, information about the host machine and CANLIB
    channel, and information about the log itself (such as start and end
    time, test location, etc.), this function creates an XML tree representing
    all of this data.
    
    Parameters:
        host_info: a MachineInfo object containing information about the host
          machine
        log_info: a LogInfo object containing information about the log file
        channel_info: a ChannelInfo object containing information about the
          CANLIB channel messages were recorded on
        msg_lists: a list of CAN.MessageList objects, representing lists of the
          messages logged on the channel provided between start_time and
          end_time. See CAN.MessageList for more information.
    """
    retval = minidom.Document()
    _log_element = retval.createElement("pycanlib_log")
    _log_element.appendChild(host_info.to_xml())
    _log_element.appendChild(log_info.to_xml())
    _log_element.appendChild(channel_info.to_xml())
    for _msg_list in msg_lists:
        _log_element.appendChild(_msg_list.to_xml())
    retval.appendChild(_log_element)
    return retval


class Bus(object):
    """
    Class: Bus

    Class representing a connection to a CAN bus using CANLIB.

    Parent class: object
    """

    def __init__(self, channel=0, flags=0, speed=1000000, tseg1=1, tseg2=0,
                 sjw=1, no_samp=1, driver_mode=canlib.canDRIVER_NORMAL,
                 name="default"):
        """
        Constructor: Bus

        Parameters:
            channel: CANLIB channel the Bus object is to connect to
            flags: flags passed to canOpenChannel when the channel is opened
            speed: bit rate of the channel to be opened
            tseg1: length of tseg1 (in time quanta). See the CAN bus
              specification for the meaning of this parameter
            tseg2: length of tseg2 (in time quanta). See the CAN bus
              specification for the meaning of this parameter
            sjw: synchronisation jump width. See the CAN bus specification
              for the meaning of this parameter
            no_samp: number of samples taken by the CAN hardware to determine
              the level of a bit
            driver_mode: mode the CAN device output driver is set to. See the
              CANLIB documentation for canSetBusOutputControl for more
              information about this parameter.
            name: name for this bus object - used to distinguish log messages
              from different bus objects
        """
        self.name = name
        BUS_CLASS_LOGGER.info("Getting read handle for new Bus instance '%s'" %
          self.name)
        self._read_handle = _get_handle(channel, flags, READ_HANDLE_REGISTRY)
        BUS_CLASS_LOGGER.info("Read handle for Bus '%s' is %d" %
                            (self.name, self._read_handle.get_canlib_handle()))
        BUS_CLASS_LOGGER.info("Getting write handle for new Bus instance '%s'" %
                            self.name)
        self._write_handle = _get_handle(channel, flags, WRITE_HANDLE_REGISTRY)
        BUS_CLASS_LOGGER.info("Write handle for Bus '%s' is %s" %
                            (self.name, self._write_handle.get_canlib_handle()))
        _old_speed = ctypes.c_long(0)
        _old_tseg1 = ctypes.c_uint(0)
        _old_tseg2 = ctypes.c_uint(0)
        _old_sjw = ctypes.c_uint(0)
        _old_sample_no = ctypes.c_uint(0)
        _old_sync_mode = ctypes.c_uint(0)
        canlib.canGetBusParams(self._read_handle.get_canlib_handle(),
          ctypes.byref(_old_speed), ctypes.byref(_old_tseg1),
          ctypes.byref(_old_tseg2), ctypes.byref(_old_sjw),
          ctypes.byref(_old_sample_no), ctypes.byref(_old_sync_mode))
        if ((speed != _old_speed.value) or (tseg1 != _old_tseg1.value) or
            (tseg2 != _old_tseg2.value) or (sjw != _old_sjw.value) or
            (no_samp != _old_sample_no.value)):
            canlib.canBusOff(self._read_handle.get_canlib_handle())
            canlib.canSetBusParams(self._read_handle.get_canlib_handle(),
                                   speed, tseg1, tseg2, sjw, no_samp, 0)
            canlib.canBusOn(self._read_handle.get_canlib_handle())
        canlib.canSetDriverMode(self._read_handle.get_canlib_handle(),
          driver_mode, canstat.canTRANSCEIVER_RESNET_NA)
        if driver_mode != canlib.canDRIVER_SILENT:
            canlib.canGetBusParams(self._write_handle.get_canlib_handle(),
              ctypes.byref(_old_speed), ctypes.byref(_old_tseg1),
              ctypes.byref(_old_tseg2), ctypes.byref(_old_sjw),
              ctypes.byref(_old_sample_no), ctypes.byref(_old_sync_mode))
            if ((speed != _old_speed.value) or (tseg1 != _old_tseg1.value) or
                (tseg2 != _old_tseg2.value) or (sjw != _old_sjw.value) or
                (no_samp != _old_sample_no.value)):
                canlib.canBusOff(self._write_handle.get_canlib_handle())
                canlib.canSetBusParams(self._write_handle.get_canlib_handle(),
                                       speed, tseg1, tseg2, sjw, no_samp, 0)
                canlib.canBusOn(self._write_handle.get_canlib_handle())
            canlib.canSetDriverMode(self._write_handle.get_canlib_handle(),
              driver_mode, canstat.canTRANSCEIVER_RESNET_NA)
        self.driver_mode = driver_mode
        self.rx_queue = Queue.Queue(0)
        self.timer_offset = self._read_handle.read_timer()
        self._read_handle.add_listener(self)

    def read(self):
        """
        Method: read

        Returns: a CAN.Message object representing the CAN message at the head
        of this Bus object's receive queue. If no messages are available, None
        is returned.
        """
        try:
            return self.rx_queue.get_nowait()
        except Queue.Empty:
            BUS_CLASS_LOGGER.debug("Bus '%s': No messages available" %
              self.name)
            return None

    def add_listener(self, listener):
        """
        Method: add_listener

        Adds a listener object to this bus. This listener object will then be
        notified immediately (via its on_message_received method) when new
        messages are received by the bus.
        """
        self._read_handle.add_listener(listener)
        listener.set_write_bus(self)

    def write(self, msg):
        """
        Method: write

        Writes a CAN.Message object to the CAN bus.

        *Note:* this function does not guarantee that the message has been
        sent when it terminates!

        Parameters:
            msg: the message to be written. Must be an instance of
            CAN.Message or one of its subclasses.
        """
        BUS_CLASS_LOGGER.debug("Bus '%s': Entering Write()" % self.name)
        if self.driver_mode != canlib.canDRIVER_SILENT:
            BUS_CLASS_LOGGER.debug("Bus '%s': writing message %s" %
              (self.name, msg))
            self._write_handle.write(msg)
        BUS_CLASS_LOGGER.debug("Bus '%s': Leaving Write()" % self.name)

    def read_timer(self):
        """
        Method: read_timer

        Reads the CAN bus timer maintained by the device used to connect to
        the bus.

        Returns:
            A floating point value representing the number of seconds since
            this Bus object was created and connected to the CAN bus.
        """
        return (float(self._read_handle.read_timer() - self.timer_offset) /
          TIMER_TICKS_PER_SECOND)

    def on_message_received(self, msg):
        """
        Method: on_message_received

        Method called by _Handle to notify this Bus object that it has
        received new messages.

        Parameters:
            msg: the received message. Must be an instance of CAN.Message or
            one of its subclasses.
        """
        self.rx_queue.put_nowait(msg)

    def _get_device_description(self):
        """
        Method: _get_device_description

        Returns: the description of the device this Bus object uses to
        connect to the CAN bus.
        """
        return self._read_handle.get_device_description()

    def _get_device_manufacturer_name(self):
        """
        Method: _get_device_manufacturer_name

        Returns: the name of the manufacturer of the device this Bus object
        uses to connect to the CAN bus.
        """
        return self._read_handle.get_device_manufacturer_name()

    def _get_device_firmware_version(self):
        """
        Method: _get_device_firmware_version

        Returns: the firmware version running on the device this Bus object
        uses to connect to the CAN bus.
        """
        return self._read_handle.get_device_firmware_version()

    def _get_device_hardware_version(self):
        """
        Method: _get_device_hardware_version

        Returns: the hardware version of the device this Bus object uses to
        connect to the CAN bus.
        """
        return self._read_handle.get_device_hardware_version()

    def _get_device_card_serial(self):
        """
        Method: _get_device_card_serial

        Returns: the *card* serial number of the device this Bus object uses
        to connect to the CAN bus.
        """
        return self._read_handle.get_device_card_serial()

    def _get_device_transceiver_serial(self):
        """
        Method: _get_device_transceiver_serial

        Returns: the *transceiver* serial number of the device this Bus object
        uses to connect to the CAN bus.
        """
        return self._read_handle.get_device_transceiver_serial()

    def _get_device_card_number(self):
        """
        Method: _get_device_card_number

        Returns: the card number of the device this Bus object uses to connect
        to the CAN bus.
        """
        return self._read_handle.get_device_card_number()

    def _get_device_channel_on_card(self):
        """
        Method: _get_device_channel_on_card

        Returns: The channel on the card used by this Bus object to connect
        to the CAN bus.
        """
        return self._read_handle.get_device_channel_on_card()

    def _get_device_transceiver_type(self):
        """
        Method: _get_device_transceiver_type

        Returns: The type of transceiver connected to the device used by this
        Bus object to connect to the CAN bus.
        """
        return self._read_handle.get_device_transceiver_type()

    def get_channel_info(self):
        """
        Method: get_channel_info

        Returns: a ChannelInfo object containing the information about the
        CAN channel this Bus object is connected to.
        """
        return ChannelInfo(None,
                           self._read_handle.channel,
                           self._get_device_description(),
                           self._get_device_manufacturer_name(),
                           self._get_device_firmware_version(),
                           self._get_device_hardware_version(),
                           self._get_device_card_serial(),
                           self._get_device_transceiver_serial(),
                           self._get_device_transceiver_type(),
                           self._get_device_card_number(),
                           self._get_device_channel_on_card())

    def get_statistics(self):
        """
        Method: get_statistics

        Returns: a BusStatistics object containing the statistics collected
        for the CANLIB channel this Bus object is connected to.
        """
        return self._read_handle.get_statistics()

@atexit.register
def _cleanup():
    """
    Method: _cleanup

    Called when the Python interpreter unloads pycanlib, and used to safely
    stop the callbacks associated with CANLIB handles opened by pycanlib.
    """
    for (_handle_number, _handle) in READ_HANDLE_REGISTRY.items():
        _handle.receiveCallbackEnabled = False
        while _handle.reading:
            canlib.canFlushReceiveQueue(_handle_number)
        canlib.kvSetNotifyCallback(_handle_number, None, None, 0)
    for (_handle_number, _handle) in WRITE_HANDLE_REGISTRY.items():
        _handle.transmitCallbackEnabled = False
        while _handle.writing:
            canlib.canFlushTransmitQueue(_handle_number)
        canlib.kvSetNotifyCallback(_handle_number, None, None, 0)
